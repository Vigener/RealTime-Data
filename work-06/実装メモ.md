
## プリセット課題からの変更点

- アーキテクチャ変更

```text
現在: Transaction.java → StockProcessor.java ← StockPrice.java
変更後: Transaction.java → PriceManager.java → StockProcessor.java
```

1. オプション1：即座更新 + 定期送信
  取引発生 → 即座に株価計算 → 100ms間隔でまとめて送信
  メリット：リアルタイム性 + 効率性
  実装難易度：中
2. オプション2：即座更新 + 即座送信
  取引発生 → 即座に株価計算 → 即座に送信
  メリット：最高のリアルタイム性
  デメリット：高頻度通信
  実装難易度：低
3. オプション3：きりの良い時間での一斉更新（既存改良）
  取引とは独立して、12:11:02.000, 12:11:02.100... で更新
  メリット：予測可能、実装簡単
  デメリット：現実性低い
  実装難易度：最低

オプション1で実装をした。

## 取引と参照する現在の株価の整合性の保証

データ整合性の問題

1. タイミングずれ: 取引処理時に参照する株価が古い可能性
2. 並行アクセス: 2つのスレッドが同じstockPriceMapを更新/参照
3. 順序保証なし: 株価更新と取引処理の順序が保証されない

**方針1**: PriceManager統合型
コンセプト: PriceManagerが取引と価格の整合性を保証し、StockProcessorには同期済みデータを送信

```text
Transaction.java → PriceManager → StockProcessor (single thread)
                      ↓
                  synchronized data
                  (transaction + current_price)
```

メリット

- データ整合性の完全保証
- StockProcessorの実装簡素化
- PriceManagerで一元管理

### 実装上の利点

#### データ整合性

- 取引処理時の価格が確実に正しい
- 価格更新と取引処理が原子的に実行される

#### パフォーマンス

- スレッド間同期の複雑性を排除
- データコピーの削減

#### 保守性

- StockProcessorの責務を明確化
- PriceManagerで価格ロジックを一元管理

この方針により、「取引発生→即座価格更新→正確な価格での取引処理」という一貫したフローが保証されます。

### 変更内容

1. アーキテクチャ変更対応

  ```text
  旧: RunConfiguration → StockPrice (独立) + Transaction (独立) → StockProcessor
  新: RunConfiguration → Transaction (PriceManager統合) → StockProcessor
  ```

2. 主な変更点

- StockPrice独立プロセス削除: PriceManagerが株価管理を担当
- 初期化順序最適化: StockPrice初期化 → Transaction起動 → StockProcessor起動
- PriceManagerシャットダウン: cleanup()でPriceManager.shutdown()を呼び出し

3. 実行フロー
   - StockPrice初期化: CSVから株価データ読み込み
   - Transaction起動: PriceManagerと連携する取引生成サービス
   - StockProcessor起動: PriceManagerから統合データを受信

4. エラーハンドリング強化
   - 各段階での詳細ログ出力
   - プロセス終了時のタイムアウト処理
   - PriceManagerの適切なシャットダウン

## 実装の流れ

### 1. **Transaction（独立サーバー）**
```
取引データ生成 → JSON化 → Socket送信（全クライアント）
```

### 2. **PriceManager（独立サーバー）**
```
Transaction接続 → データ受信 → 価格計算・付与 → StockProcessor送信
```

### 3. **StockProcessor（クライアント）**
```
PriceManager接続 → 価格付きデータ受信 → 集計・フロントエンド送信
```

## メリット

### 1. **完全分離**
- TransactionはPriceManagerを知らない
- 純粋なSocket通信のみ

### 2. **拡張性**
- Transactionに複数のクライアント（PriceManager以外）を接続可能
- 各サーバーが独立してスケール可能

### 3. **テスト容易性**
- 各コンポーネントを独立してテスト可能
- Transactionサーバーのみ起動して動作確認可能

### 4. **障害耐性**
- PriceManagerがダウンしてもTransactionは動作継続
- Transactionが再起動してもPriceManagerが自動再接続

この実装により、TransactionはPriceManagerを直接呼び出すことなく、純粋なSocket通信ベースの分離アーキテクチャが実現できます。


## 拡張・展望

### Transaction.javaにおける高度な保有株数管理（将来の拡張）

```java
// 将来的な拡張: 簡易保有株数管理
private static ConcurrentHashMap<String, Integer> shareholderStockHoldings = new ConcurrentHashMap<>();

private static int generateSmartQuantity(int shareholderId, int stockId) {
    String key = shareholderId + "-" + stockId;
    int currentHoldings = shareholderStockHoldings.getOrDefault(key, 0);
    
    // 現在の保有状況に応じて売買傾向を調整
    if (currentHoldings > 100) {
        // 大量保有時は売り傾向
        return random.nextInt(81) - 60; // -60 to +20
    } else if (currentHoldings < -50) {
        // 大量空売り時は買い戻し傾向
        return random.nextInt(61) + 10; // +10 to +70
    } else {
        // 通常時はバランス良く
        return generateBalancedQuantity();
    }
}
```

ほかにも、メタデータに長期保有傾向、デイトレード（短期売買）傾向など株主ごとに設定し、取引量を調整することで、よりリアルな市場動向を模倣できそう。