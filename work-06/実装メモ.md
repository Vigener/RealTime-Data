
## プリセット課題からの変更点

- アーキテクチャ変更

```text
現在: Transaction.java → StockProcessor.java ← StockPrice.java
変更後: Transaction.java → PriceManager.java → StockProcessor.java
```

1. オプション1：即座更新 + 定期送信
  取引発生 → 即座に株価計算 → 100ms間隔でまとめて送信
  メリット：リアルタイム性 + 効率性
  実装難易度：中
2. オプション2：即座更新 + 即座送信
  取引発生 → 即座に株価計算 → 即座に送信
  メリット：最高のリアルタイム性
  デメリット：高頻度通信
  実装難易度：低
3. オプション3：きりの良い時間での一斉更新（既存改良）
  取引とは独立して、12:11:02.000, 12:11:02.100... で更新
  メリット：予測可能、実装簡単
  デメリット：現実性低い
  実装難易度：最低

オプション1で実装をした。

## 取引と参照する現在の株価の整合性の保証

データ整合性の問題

1. タイミングずれ: 取引処理時に参照する株価が古い可能性
2. 並行アクセス: 2つのスレッドが同じstockPriceMapを更新/参照
3. 順序保証なし: 株価更新と取引処理の順序が保証されない

**方針1**: PriceManager統合型
コンセプト: PriceManagerが取引と価格の整合性を保証し、StockProcessorには同期済みデータを送信

```text
Transaction.java → PriceManager → StockProcessor (single thread)
                      ↓
                  synchronized data
                  (transaction + current_price)
```

メリット

- データ整合性の完全保証
- StockProcessorの実装簡素化
- PriceManagerで一元管理

### 実装上の利点

#### データ整合性

- 取引処理時の価格が確実に正しい
- 価格更新と取引処理が原子的に実行される

#### パフォーマンス

- スレッド間同期の複雑性を排除
- データコピーの削減

#### 保守性

- StockProcessorの責務を明確化
- PriceManagerで価格ロジックを一元管理

この方針により、「取引発生→即座価格更新→正確な価格での取引処理」という一貫したフローが保証されます。

### 変更内容

1. アーキテクチャ変更対応

  ```text
  旧: RunConfiguration → StockPrice (独立) + Transaction (独立) → StockProcessor
  新: RunConfiguration → Transaction (PriceManager統合) → StockProcessor
  ```

2. 主な変更点

- StockPrice独立プロセス削除: PriceManagerが株価管理を担当
- 初期化順序最適化: StockPrice初期化 → Transaction起動 → StockProcessor起動
- PriceManagerシャットダウン: cleanup()でPriceManager.shutdown()を呼び出し

3. 実行フロー
   - StockPrice初期化: CSVから株価データ読み込み
   - Transaction起動: PriceManagerと連携する取引生成サービス
   - StockProcessor起動: PriceManagerから統合データを受信

4. エラーハンドリング強化
   - 各段階での詳細ログ出力
   - プロセス終了時のタイムアウト処理
   - PriceManagerの適切なシャットダウン

## 実装の流れ

### 1. **Transaction（独立サーバー）**
```
取引データ生成 → JSON化 → Socket送信（全クライアント）
```

### 2. **PriceManager（独立サーバー）**
```
Transaction接続 → データ受信 → 価格計算・付与 → StockProcessor送信
```

### 3. **StockProcessor（クライアント）**
```
PriceManager接続 → 価格付きデータ受信 → 集計・フロントエンド送信
```

## メリット

### 1. **完全分離**
- TransactionはPriceManagerを知らない
- 純粋なSocket通信のみ

### 2. **拡張性**
- Transactionに複数のクライアント（PriceManager以外）を接続可能
- 各サーバーが独立してスケール可能

### 3. **テスト容易性**
- 各コンポーネントを独立してテスト可能
- Transactionサーバーのみ起動して動作確認可能

### 4. **障害耐性**
- PriceManagerがダウンしてもTransactionは動作継続
- Transactionが再起動してもPriceManagerが自動再接続

この実装により、TransactionはPriceManagerを直接呼び出すことなく、純粋なSocket通信ベースの分離アーキテクチャが実現できます。

## 問題点

非常に鋭い分析ですね！確かにTransaction.javaとStockProcessorの間で保有株数の同期が取れていないことが根本的な問題です。

### 問題の詳細分析

現在の問題

1. Transaction.java: 起動時から保有株数を蓄積2. StockProcessor: 途中から接続して取引を監視開始
3. データ不整合: StockProcessorが知らない過去の取引に基づいてTransaction.javaが売却判断

### 解決案の比較

案1: StockProcessor接続まで取引スキップ（推奨）

### 実装中につまった点

- Transaction ↔ PriceManager ↔ StockProcessorのように双方向通信を設定して、StockProcessorとPriceManagerの接続状況をTransaction.javaに伝える必要があり、書き換えが〆切の制約もあり、書ききれなかった。

### 代替案として実装したこと。

- 一貫して、空売りはなしという前提で進めた。
- そのうえで、マイナスの株は一旦見た目上表示しないということにする。
- フロントエンド側のフィルタリングのみで突貫工事で対応した。
- アルゴリズム的には間違っているが、バックエンド側を修正できた際に、フィルタリングを解除するだけでフロントエンドがもとに戻る。時間効率も考えてこのようにした。

```typescript
  <tbody>
    {portfolioSummary.stocks
      .filter(stock => stock.quantity > 0) // **追加**: マイナス保有を除外
      .map(stock => (
        <tr key={stock.stockId}>
          <td style={{ textAlign: "center" }}>{stock.stockId}</td>
          <td>{stock.stockName}</td>
      // 省略
    }
  </tbody>
```